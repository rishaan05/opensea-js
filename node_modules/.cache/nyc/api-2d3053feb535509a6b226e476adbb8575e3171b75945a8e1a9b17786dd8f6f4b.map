{"version":3,"file":"/Users/rg/dev/opensea-js/src/api/api.ts","sources":["/Users/rg/dev/opensea-js/src/api/api.ts"],"names":[],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport {\n  getCollectionPath,\n  getOrdersAPIPath,\n  getPostCollectionOfferPath,\n  getBuildOfferPath,\n  getListNFTsByCollectionPath,\n  getListNFTsByContractPath,\n  getNFTPath,\n  getRefreshMetadataPath,\n  getCollectionOffersPath,\n  getListNFTsByAccountPath,\n  getBestOfferAPIPath,\n  getBestListingAPIPath,\n  getAllOffersAPIPath,\n  getAllListingsAPIPath,\n  getPaymentTokenPath,\n  getAccountPath,\n  getCollectionStatsPath,\n  getBestListingsAPIPath,\n} from \"./apiPaths\";\nimport {\n  BuildOfferResponse,\n  GetCollectionResponse,\n  ListNFTsResponse,\n  GetNFTResponse,\n  ListCollectionOffersResponse,\n  GetOrdersResponse,\n  GetBestOfferResponse,\n  GetBestListingResponse,\n  GetOffersResponse,\n  GetListingsResponse,\n  CollectionOffer,\n} from \"./types\";\nimport { API_BASE_MAINNET, API_BASE_TESTNET } from \"../constants\";\nimport {\n  FulfillmentDataResponse,\n  OrderAPIOptions,\n  OrdersPostQueryResponse,\n  OrdersQueryOptions,\n  OrdersQueryResponse,\n  OrderV2,\n  ProtocolData,\n} from \"../orders/types\";\nimport {\n  serializeOrdersQueryOptions,\n  deserializeOrder,\n  getFulfillmentDataPath,\n  getFulfillListingPayload,\n  getFulfillOfferPayload,\n  getBuildCollectionOfferPayload,\n  getPostCollectionOfferPayload,\n} from \"../orders/utils\";\nimport {\n  Chain,\n  OpenSeaAPIConfig,\n  OpenSeaAccount,\n  OpenSeaCollection,\n  OpenSeaCollectionStats,\n  OpenSeaPaymentToken,\n  OrderSide,\n} from \"../types\";\nimport {\n  paymentTokenFromJSON,\n  collectionFromJSON,\n  isTestChain,\n  accountFromJSON,\n} from \"../utils/utils\";\n\nfunction stall(duration: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, duration);\n  });\n}\n\n/**\n * The API class for the OpenSea SDK.\n * @category Main Classes\n */\nexport class OpenSeaAPI {\n  /**\n   * Base url for the API\n   */\n  public readonly apiBaseUrl: string;\n  /**\n   * Default size to use for fetching orders\n   */\n  public pageSize = 20;\n  /**\n   * Logger function to use when debugging\n   */\n  public logger: (arg: string) => void;\n\n  private apiKey: string | undefined;\n  private chain: Chain;\n\n  /**\n   * Create an instance of the OpenSeaAPI\n   * @param config OpenSeaAPIConfig for setting up the API, including an optional API key, Chain name, and base URL\n   * @param logger Optional function for logging debug strings before and after requests are made. Defaults to no logging\n   */\n  constructor(config: OpenSeaAPIConfig, logger?: (arg: string) => void) {\n    this.apiKey = config.apiKey;\n    this.chain = config.chain ?? Chain.Mainnet;\n\n    this.apiBaseUrl = isTestChain(this.chain)\n      ? API_BASE_TESTNET\n      : API_BASE_MAINNET;\n\n    // Debugging: default to nothing\n    this.logger = logger ?? ((arg: string) => arg);\n  }\n\n  /**\n   * Gets an order from API based on query options.\n   * @param options\n   * @param options.side The side of the order (buy or sell\n   * @param options.protocol The protocol, typically seaport, to query orders for\n   * @param options.orderDirection The direction to sort the orders\n   * @param options.orderBy The field to sort the orders by\n   * @param options.limit The number of orders to retrieve\n   * @param options.maker Filter by the wallet address of the order maker\n   * @param options.taker Filter by  wallet address of the order taker\n   * @param options.asset_contract_address Address of the NFT's contract\n   * @param options.token_ids String array of token IDs to filter by.\n   * @param options.listed_after Filter by orders listed after the Unix epoch timestamp in seconds\n   * @param options.listed_before Filter by orders listed before the Unix epoch timestamp in seconds\n   * @returns The first {@link OrderV2} returned by the API\n   *\n   * @throws An error if there are no matching orders.\n   */\n  public async getOrder({\n    side,\n    protocol = \"seaport\",\n    orderDirection = \"desc\",\n    orderBy = \"created_date\",\n    ...restOptions\n  }: Omit<OrdersQueryOptions, \"limit\">): Promise<OrderV2> {\n    const { orders } = await this.get<OrdersQueryResponse>(\n      getOrdersAPIPath(this.chain, protocol, side),\n      serializeOrdersQueryOptions({\n        limit: 1,\n        orderBy,\n        orderDirection,\n        ...restOptions,\n      }),\n    );\n    if (orders.length === 0) {\n      throw new Error(\"Not found: no matching order found\");\n    }\n    return deserializeOrder(orders[0]);\n  }\n\n  /**\n   * Gets a list of orders from API based on query options.\n   * @param options\n   * @param options.side The side of the order (buy or sell)\n   * @param options.protocol The protocol, typically seaport, to query orders for\n   * @param options.orderDirection The direction to sort the orders\n   * @param options.orderBy The field to sort the orders by\n   * @param options.limit The number of orders to retrieve\n   * @param options.maker Filter by the wallet address of the order maker\n   * @param options.taker Filter by  wallet address of the order taker\n   * @param options.asset_contract_address Address of the NFT's contract\n   * @param options.token_ids String array of token IDs to filter by.\n   * @param options.listed_after Filter by orders listed after the Unix epoch timestamp in seconds\n   * @param options.listed_before Filter by orders listed before the Unix epoch timestamp in seconds\n   * @returns The {@link GetOrdersResponse} returned by the API.\n   */\n  public async getOrders({\n    side,\n    protocol = \"seaport\",\n    orderDirection = \"desc\",\n    orderBy = \"created_date\",\n    ...restOptions\n  }: Omit<OrdersQueryOptions, \"limit\">): Promise<GetOrdersResponse> {\n    const response = await this.get<OrdersQueryResponse>(\n      getOrdersAPIPath(this.chain, protocol, side),\n      serializeOrdersQueryOptions({\n        limit: this.pageSize,\n        orderBy,\n        orderDirection,\n        ...restOptions,\n      }),\n    );\n    return {\n      ...response,\n      orders: response.orders.map(deserializeOrder),\n    };\n  }\n\n  /**\n   * Gets all offers for a given collection.\n   * @param collectionSlug The slug of the collection.\n   * @param limit The number of offers to return. Must be between 1 and 100. Default: 100\n   * @param next The cursor for the next page of results. This is returned from a previous request.\n   * @returns The {@link GetOffersResponse} returned by the API.\n   */\n  public async getAllOffers(\n    collectionSlug: string,\n    limit?: number,\n    next?: string,\n  ): Promise<GetOffersResponse> {\n    const response = await this.get<GetOffersResponse>(\n      getAllOffersAPIPath(collectionSlug),\n      {\n        limit,\n        next,\n      },\n    );\n    return response;\n  }\n\n  /**\n   * Gets all listings for a given collection.\n   * @param collectionSlug The slug of the collection.\n   * @param limit The number of listings to return. Must be between 1 and 100. Default: 100\n   * @param next The cursor for the next page of results. This is returned from a previous request.\n   * @returns The {@link GetListingsResponse} returned by the API.\n   */\n  public async getAllListings(\n    collectionSlug: string,\n    limit?: number,\n    next?: string,\n  ): Promise<GetListingsResponse> {\n    const response = await this.get<GetListingsResponse>(\n      getAllListingsAPIPath(collectionSlug),\n      {\n        limit,\n        next,\n      },\n    );\n    return response;\n  }\n\n  /**\n   * Gets the best offer for a given token.\n   * @param collectionSlug The slug of the collection.\n   * @param tokenId The token identifier.\n   * @returns The {@link GetBestOfferResponse} returned by the API.\n   */\n  public async getBestOffer(\n    collectionSlug: string,\n    tokenId: string | number,\n  ): Promise<GetBestOfferResponse> {\n    const response = await this.get<GetBestOfferResponse>(\n      getBestOfferAPIPath(collectionSlug, tokenId),\n    );\n    return response;\n  }\n\n  /**\n   * Gets the best listing for a given token.\n   * @param collectionSlug The slug of the collection.\n   * @param tokenId The token identifier.\n   * @returns The {@link GetBestListingResponse} returned by the API.\n   */\n  public async getBestListing(\n    collectionSlug: string,\n    tokenId: string | number,\n  ): Promise<GetBestListingResponse> {\n    const response = await this.get<GetBestListingResponse>(\n      getBestListingAPIPath(collectionSlug, tokenId),\n    );\n    return response;\n  }\n\n  /**\n   * Gets the best listings for a given collection.\n   * @param collectionSlug The slug of the collection.\n   * @param limit The number of listings to return. Must be between 1 and 100. Default: 100\n   * @param next The cursor for the next page of results. This is returned from a previous request.\n   * @returns The {@link GetListingsResponse} returned by the API.\n   */\n  public async getBestListings(\n    collectionSlug: string,\n    limit?: number,\n    next?: string,\n  ): Promise<GetListingsResponse> {\n    const response = await this.get<GetListingsResponse>(\n      getBestListingsAPIPath(collectionSlug),\n      {\n        limit,\n        next,\n      },\n    );\n    return response;\n  }\n\n  /**\n   * Generate the data needed to fulfill a listing or an offer onchain.\n   * @param fulfillerAddress The wallet address which will be used to fulfill the order\n   * @param orderHash The hash of the order to fulfill\n   * @param protocolAddress The address of the seaport contract\n   * @side The side of the order (buy or sell)\n   * @returns The {@link FulfillmentDataResponse}\n   */\n  public async generateFulfillmentData(\n    fulfillerAddress: string,\n    orderHash: string,\n    protocolAddress: string,\n    side: OrderSide,\n  ): Promise<FulfillmentDataResponse> {\n    let payload: object | null = null;\n    if (side === OrderSide.ASK) {\n      payload = getFulfillListingPayload(\n        fulfillerAddress,\n        orderHash,\n        protocolAddress,\n        this.chain,\n      );\n    } else {\n      payload = getFulfillOfferPayload(\n        fulfillerAddress,\n        orderHash,\n        protocolAddress,\n        this.chain,\n      );\n    }\n    const response = await this.post<FulfillmentDataResponse>(\n      getFulfillmentDataPath(side),\n      payload,\n    );\n    return response;\n  }\n\n  /**\n   * Post an order to OpenSea.\n   * @param order The order to post\n   * @param apiOptions\n   * @param apiOptions.protocol The protocol, typically seaport, to post the order to.\n   * @param apiOptions.side The side of the order (buy or sell).\n   * @param apiOptions.protocolAddress The address of the seaport contract.\n   * @param options\n   * @returns The {@link OrderV2} posted to the API.\n   */\n  public async postOrder(\n    order: ProtocolData,\n    apiOptions: OrderAPIOptions,\n  ): Promise<OrderV2> {\n    // TODO: Validate apiOptions. Avoid API calls that will definitely fail\n    const { protocol = \"seaport\", side, protocolAddress } = apiOptions;\n    const response = await this.post<OrdersPostQueryResponse>(\n      getOrdersAPIPath(this.chain, protocol, side),\n      { ...order, protocol_address: protocolAddress },\n    );\n    return deserializeOrder(response.order);\n  }\n\n  /**\n   * Build a OpenSea collection offer.\n   * @param offererAddress The wallet address which is creating the offer.\n   * @param quantity The number of NFTs requested in the offer.\n   * @param collectionSlug The slug (identifier) of the collection to build the offer for.\n   * @param offerProtectionEnabled Build the offer on OpenSea's signed zone to provide offer protections from receiving an item which is disabled from trading.\n   * @param traitType If defined, the trait name to create the collection offer for.\n   * @param traitValue If defined, the trait value to create the collection offer for.\n   * @returns The {@link BuildOfferResponse} returned by the API.\n   */\n  public async buildOffer(\n    offererAddress: string,\n    quantity: number,\n    collectionSlug: string,\n    offerProtectionEnabled = true,\n    traitType?: string,\n    traitValue?: string,\n  ): Promise<BuildOfferResponse> {\n    if (traitType || traitValue) {\n      if (!traitType || !traitValue) {\n        throw new Error(\n          \"Both traitType and traitValue must be defined if one is defined.\"\n        );\n      }\n    }\n    const payload = getBuildCollectionOfferPayload(\n      offererAddress,\n      quantity,\n      collectionSlug,\n      offerProtectionEnabled,\n      traitType,\n      traitValue,\n    );\n    const response = await this.post<BuildOfferResponse>(\n      getBuildOfferPath(),\n      payload,\n    );\n    return response;\n  }\n\n  /**\n   * Get a list collection offers for a given slug.\n   * @param slug The slug (identifier) of the collection to list offers for\n   * @returns The {@link ListCollectionOffersResponse} returned by the API.\n   */\n  public async getCollectionOffers(\n    slug: string,\n  ): Promise<ListCollectionOffersResponse | null> {\n    return await this.get<ListCollectionOffersResponse>(\n      getCollectionOffersPath(slug),\n    );\n  }\n\n  /**\n   * Post a collection offer to OpenSea.\n   * @param order The collection offer to post.\n   * @param slug The slug (identifier) of the collection to post the offer for.\n   * @returns The {@link Offer} returned to the API.\n   */\n  public async postCollectionOffer(\n    order: ProtocolData,\n    slug: string,\n  ): Promise<CollectionOffer | null> {\n    const payload = getPostCollectionOfferPayload(slug, order);\n    return await this.post<CollectionOffer>(\n      getPostCollectionOfferPath(),\n      payload,\n    );\n  }\n\n  /**\n   * Fetch multiple NFTs for a collection.\n   * @param slug The slug (identifier) of the collection\n   * @param limit The number of NFTs to retrieve. Must be greater than 0 and less than 51.\n   * @param next Cursor to retrieve the next page of NFTs\n   * @returns The {@link ListNFTsResponse} returned by the API.\n   */\n  public async getNFTsByCollection(\n    slug: string,\n    limit: number | undefined = undefined,\n    next: string | undefined = undefined,\n  ): Promise<ListNFTsResponse> {\n    const response = await this.get<ListNFTsResponse>(\n      getListNFTsByCollectionPath(slug),\n      {\n        limit,\n        next,\n      },\n    );\n    return response;\n  }\n\n  /**\n   * Fetch multiple NFTs for a contract.\n   * @param address The NFT's contract address.\n   * @param limit The number of NFTs to retrieve. Must be greater than 0 and less than 51.\n   * @param next Cursor to retrieve the next page of NFTs.\n   * @param chain The NFT's chain.\n   * @returns The {@link ListNFTsResponse} returned by the API.\n   */\n  public async getNFTsByContract(\n    address: string,\n    limit: number | undefined = undefined,\n    next: string | undefined = undefined,\n    chain: Chain = this.chain,\n  ): Promise<ListNFTsResponse> {\n    const response = await this.get<ListNFTsResponse>(\n      getListNFTsByContractPath(chain, address),\n      {\n        limit,\n        next,\n      },\n    );\n    return response;\n  }\n\n  /**\n   * Fetch NFTs owned by an account.\n   * @param address The address of the account\n   * @param limit The number of NFTs to retrieve. Must be greater than 0 and less than 51.\n   * @param next Cursor to retrieve the next page of NFTs\n   * @param chain The chain to query. Defaults to the chain set in the constructor.\n   * @returns The {@link ListNFTsResponse} returned by the API.\n   */\n  public async getNFTsByAccount(\n    address: string,\n    limit: number | undefined = undefined,\n    next: string | undefined = undefined,\n    chain = this.chain,\n  ): Promise<ListNFTsResponse> {\n    const response = await this.get<ListNFTsResponse>(\n      getListNFTsByAccountPath(chain, address),\n      {\n        limit,\n        next,\n      },\n    );\n\n    return response;\n  }\n\n  /**\n   * Fetch metadata, traits, ownership information, and rarity for a single NFT.\n   * @param address The NFT's contract address.\n   * @param identifier the identifier of the NFT (i.e. Token ID)\n   * @param chain The NFT's chain.\n   * @returns The {@link GetNFTResponse} returned by the API.\n   */\n  public async getNFT(\n    address: string,\n    identifier: string,\n    chain = this.chain,\n  ): Promise<GetNFTResponse> {\n    const response = await this.get<GetNFTResponse>(\n      getNFTPath(chain, address, identifier),\n    );\n    return response;\n  }\n\n  /**\n   * Fetch an OpenSea collection.\n   * @param slug The slug (identifier) of the collection.\n   * @returns The {@link OpenSeaCollection} returned by the API.\n   */\n  public async getCollection(slug: string): Promise<OpenSeaCollection> {\n    const path = getCollectionPath(slug);\n    const response = await this.get<GetCollectionResponse>(path);\n    return collectionFromJSON(response);\n  }\n\n  /**\n   * Fetch stats for an OpenSea collection.\n   * @param slug The slug (identifier) of the collection.\n   * @returns The {@link OpenSeaCollection} returned by the API.\n   */\n  public async getCollectionStats(\n    slug: string,\n  ): Promise<OpenSeaCollectionStats> {\n    const path = getCollectionStatsPath(slug);\n    const response = await this.get<OpenSeaCollectionStats>(path);\n    return response as OpenSeaCollectionStats;\n  }\n\n  /**\n   * Fetch a payment token.\n   * @param query Query to use for getting tokens. See {@link OpenSeaPaymentTokenQuery}.\n   * @param next The cursor for the next page of results. This is returned from a previous request.\n   * @returns The {@link OpenSeaPaymentToken} returned by the API.\n   */\n  public async getPaymentToken(\n    address: string,\n    chain = this.chain,\n  ): Promise<OpenSeaPaymentToken> {\n    const json = await this.get<OpenSeaPaymentToken>(\n      getPaymentTokenPath(chain, address),\n    );\n    return paymentTokenFromJSON(json);\n  }\n\n  /**\n   * Fetch account for an address.\n   * @param query Query to use for getting tokens. See {@link OpenSeaPaymentTokenQuery}.\n   * @param next The cursor for the next page of results. This is returned from a previous request.\n   * @returns The {@link GetAccountResponse} returned by the API.\n   */\n  public async getAccount(address: string): Promise<OpenSeaAccount> {\n    const json = await this.get<OpenSeaAccount>(getAccountPath(address));\n    return accountFromJSON(json);\n  }\n\n  /**\n   * Force refresh the metadata for an NFT.\n   * @param address The address of the NFT's contract.\n   * @param identifier The identifier of the NFT.\n   * @param chain The chain where the NFT is located.\n   * @returns The response from the API.\n   */\n  public async refreshNFTMetadata(\n    address: string,\n    identifier: string,\n    chain: Chain = this.chain,\n  ): Promise<Response> {\n    const response = await this.post<Response>(\n      getRefreshMetadataPath(chain, address, identifier),\n      {},\n    );\n\n    return response;\n  }\n\n  /**\n   * Generic fetch method for any API endpoint\n   * @param apiPath Path to URL endpoint under API\n   * @param query URL query params. Will be used to create a URLSearchParams object.\n   * @returns @typeParam T The response from the API.\n   */\n  public async get<T>(apiPath: string, query: object = {}): Promise<T> {\n    const qs = this.objectToSearchParams(query);\n    const url = `${this.apiBaseUrl}${apiPath}?${qs}`;\n    return await this._fetch(url);\n  }\n\n  /**\n   * Generic post method for any API endpoint.\n   * @param apiPath Path to URL endpoint under API\n   * @param body Data to send.\n   * @param opts ethers ConnectionInfo, similar to Fetch API.\n   * @returns @typeParam T The response from the API.\n   */\n  public async post<T>(\n    apiPath: string,\n    body?: object,\n    opts?: object,\n  ): Promise<T> {\n    const url = `${this.apiBaseUrl}${apiPath}`;\n    return await this._fetch(url, opts, body);\n  }\n\n  private objectToSearchParams(params: object = {}) {\n    const urlSearchParams = new URLSearchParams();\n\n    Object.entries(params).forEach(([key, value]) => {\n      if (value && Array.isArray(value)) {\n        value.forEach((item) => item && urlSearchParams.append(key, item));\n      } else if (value) {\n        urlSearchParams.append(key, value);\n      }\n    });\n\n    return urlSearchParams.toString();\n  }\n\n  /**\n   * Get from an API Endpoint, sending auth token in headers\n   * @param opts ethers ConnectionInfo, similar to Fetch API\n   * @param body Optional body to send. If set, will POST, otherwise GET\n   */\n  private async _fetch(url: string, headers?: object, body?: object) {\n    // Create the fetch request\n    const req = new ethers.FetchRequest(url);\n\n    // Set the headers\n    headers = {\n      \"x-app-id\": \"opensea-js\",\n      ...(this.apiKey ? { \"X-API-KEY\": this.apiKey } : {}),\n      ...headers,\n    };\n    for (const [key, value] of Object.entries(headers)) {\n      req.setHeader(key, value);\n    }\n\n    // Set the body if provided\n    if (body) {\n      req.body = body;\n    }\n\n    // Set the throttle params\n    // - Should be able to replace this retryFunc with `setThrottleParams({ slotInterval: 1000 })`\n    //   when this bug is fixed in ethers: https://github.com/ethers-io/ethers.js/issues/4663\n    req.retryFunc = async (_req, resp, attempt) => {\n      this.logger(\n        `Fetch attempt ${attempt} failed with status ${resp.statusCode}`,\n      );\n      // Wait 1s between tries\n      await stall(1000);\n      return true;\n    };\n\n    this.logger(\n      `Sending request: ${url} ${JSON.stringify({\n        request: req,\n        headers: req.headers,\n      })}`,\n    );\n\n    const response = await req.send();\n    if (!response.ok()) {\n      // If an errors array is returned, throw with the error messages.\n      const errors = response.bodyJson?.errors;\n      if (errors?.length > 0) {\n        throw new Error(`Server Error: ${errors.join(\", \")}`);\n      } else {\n        // Otherwise, let ethers throw a SERVER_ERROR since it will include\n        // more context about the request and response.\n        response.assertOk();\n      }\n    }\n    return response.bodyJson;\n  }\n}\n"]}
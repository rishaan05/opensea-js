{"version":3,"file":"/Users/rg/dev/opensea-js/test/api/postOrder.validation.spec.ts","sources":["/Users/rg/dev/opensea-js/test/api/postOrder.validation.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect } from \"chai\";\nimport { suite, test } from \"mocha\";\nimport { OpenSeaAPI } from \"../../src/api/api\";\nimport { OrderAPIOptions } from \"../../src/orders/types\";\nimport { Chain, OrderSide } from \"../../src/types\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nsuite(\"API: postOrder validation\", () => {\n  const api = new OpenSeaAPI({ chain: Chain.Mainnet });\n  const mockOrder: any = {\n    parameters: {\n      offerer: \"0x1234567890123456789012345678901234567890\",\n      zone: \"0x1234567890123456789012345678901234567890\",\n      orderType: 0,\n      startTime: \"1234567890\",\n      endTime: \"9876543210\",\n      zoneHash:\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n      salt: \"1234567890\",\n      offer: [],\n      consideration: [],\n      totalOriginalConsiderationItems: 0,\n      conduitKey:\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    },\n    signature: \"0x\",\n  };\n\n  test(\"should throw error when side is missing\", async () => {\n    const apiOptions = {\n      protocolAddress: \"0x1234567890123456789012345678901234567890\",\n    };\n\n    try {\n      await api.postOrder(mockOrder, apiOptions as OrderAPIOptions);\n      expect.fail(\"Should have thrown an error\");\n    } catch (error: any) {\n      expect(error.message).to.equal(\"apiOptions.side is required\");\n    }\n  });\n\n  test(\"should throw error when protocolAddress is missing\", async () => {\n    const apiOptions = {\n      side: OrderSide.LISTING,\n    };\n\n    try {\n      await api.postOrder(mockOrder, apiOptions as OrderAPIOptions);\n      expect.fail(\"Should have thrown an error\");\n    } catch (error: any) {\n      expect(error.message).to.equal(\"apiOptions.protocolAddress is required\");\n    }\n  });\n\n  test(\"should throw error when order is missing\", async () => {\n    const apiOptions = {\n      side: OrderSide.LISTING,\n      protocolAddress: \"0x1234567890123456789012345678901234567890\",\n    } as OrderAPIOptions;\n\n    try {\n      await api.postOrder(null as any, apiOptions);\n      expect.fail(\"Should have thrown an error\");\n    } catch (error: any) {\n      expect(error.message).to.equal(\"order data is required\");\n    }\n  });\n\n  test(\"should throw error for unsupported protocol\", async () => {\n    const apiOptions = {\n      protocol: \"unsupported\" as \"seaport\",\n      side: OrderSide.LISTING,\n      protocolAddress: \"0x1234567890123456789012345678901234567890\",\n    };\n\n    try {\n      await api.postOrder(mockOrder, apiOptions);\n      expect.fail(\"Should have thrown an error\");\n    } catch (error: any) {\n      expect(error.message).to.equal(\n        \"Currently only 'seaport' protocol is supported\",\n      );\n    }\n  });\n\n  test(\"should throw error for invalid side value\", async () => {\n    const apiOptions = {\n      side: \"invalid_side\" as OrderSide,\n      protocolAddress: \"0x1234567890123456789012345678901234567890\",\n    };\n\n    try {\n      await api.postOrder(mockOrder, apiOptions);\n      expect.fail(\"Should have thrown an error\");\n    } catch (error: any) {\n      expect(error.message).to.equal(\"side must be either 'ask' or 'bid'\");\n    }\n  });\n\n  test(\"should throw error for invalid protocol address format\", async () => {\n    const apiOptions = {\n      side: OrderSide.LISTING,\n      protocolAddress: \"invalid_address\",\n    } as OrderAPIOptions;\n\n    try {\n      await api.postOrder(mockOrder, apiOptions);\n      expect.fail(\"Should have thrown an error\");\n    } catch (error: any) {\n      expect(error.message).to.equal(\"Invalid protocol address format\");\n    }\n  });\n});\n"]}